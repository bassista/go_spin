# Agent Knowledge Base - go_spin

## Panoramica del Progetto
**go_spin** è un'applicazione Go per la gestione schedulata dei container Docker. Include un'interfaccia Web SPA (Alpine.js) per la gestione visuale e un'API REST completa per l'accesso programmatico.

### Funzionalità Principali
- **Gestione Container**: Registrazione e controllo di container Docker con nomi friendly e URL
- **Gruppi**: Organizzazione di container in gruppi logici per operazioni batch
- **Scheduling**: Definizione di schedule temporali con timer multipli per target
- **Avvio/Stop Automatico**: Container avviati/fermati automaticamente secondo gli schedule
- **Web UI**: Interfaccia SPA moderna costruita con Alpine.js
- **API REST**: API JSON completa per accesso programmatico
- **File Watching**: Ricaricamento automatico configurazione quando il file JSON cambia esternamente
- **Graceful Shutdown**: Cleanup appropriato alla terminazione dell'applicazione

## Pattern Architetturali Chiave

### 1. Dirty-Tracking Pattern
- La **cache in-memory** (`internal/cache/store.go`) mantiene una copia dei dati con flag `dirty`
- **I controller HTTP NON persistono direttamente** - marcano solo la cache come dirty
- Una goroutine schedulata (`cache.StartPersistenceScheduler`) salva periodicamente il JSON se dirty
- **Vantaggi**: evita I/O bloccante sulle API, omogeneizza persistenza asincrona

### 2. Interface-Driven Design
Ogni modulo espone interfacce minimali:
- `ContainerRuntime` - astrae Docker/Memory runtime
- `Repository` - astrae persistenza
- `AppStore` - interfaccia cache
- Questo facilita **testing senza Docker** e **mocking**

### 3. Hexagonal Architecture (Ports & Adapters)
- Logica business isolata in `controller/` e `cache/`
- Dipendenze esterne astratte tramite interfacce
- Implementazioni runtime (Docker/Memory) sono intercambiabili
- Pattern Repository astrae la persistenza dati

### 4. Optimistic Locking
- `metadata.lastUpdate` (Unix ms in config.json) previene race condition su modifiche esterne
- File-watching con `fsnotify` rileva modifiche esterne e ricarica automaticamente

### 5. Factory Pattern
- `runtime.NewRuntimeFromConfig(runtimeType, doc)` crea implementazioni runtime appropriate
- Permette switching configurabile tra Docker e Memory runtime
- Facilita testing e deployment flessibile

## Workflow di Caricamento Dati
1. `JSONRepository.Load()` legge `config/data/config.json`
2. Validazione della struttura (tags `validate:"required,url"`)
3. Creazione `DataDocument` in cache
4. Goroutine file-watching per aggiornamenti esterni
5. Goroutine persistence scheduler per salvataggi periodici

## Flusso di Elaborazione Richieste
```
HTTP Request → Gin Router → Controller → Cache Store → Mark Dirty → Response
                                     ↓
                           Background Persister → JSON Repository → File System
```

## Build & Development

### Build
```bash
go build -o .build/main ./cmd/server/main.go
./.build/main
```

### Hot-Reload (Air)
```bash
air -c .air.toml              # Linux/macOS
air -c .air_win.toml          # Windows
```

### Test
```bash
go test ./...
```

### Pre-commit Checklist
- `go vet ./...` - always before commit
- `go fmt ./...` - standard formatting
- `golangci-lint run` - linting
- `go mod tidy` - clean dependencies
- `go test ./...` - all tests must pass

## Configuration
- **File**: `config/config.yaml` (Viper + dotenv)
- **Env prefix**: `GO_SPIN_`
- **Config path**: via `GO_SPIN_CONFIG_PATH` (default: `./config`)
- **Directory auto-create**: if `data.file_path` does not exist, it is created at startup

### Important variables
- `server.port`, `data.file_path`, `data.persist_interval_secs`
- `misc.scheduling_enabled`, `misc.scheduling_poll_interval_secs`
- `misc.runtime_type` ("docker" or "memory")
- `misc.cors_allowed_origins`
- `WAITING_SERVER_PORT`: second server to expose only the route `/runtime/:name/waiting`.

## Main Data Structure
```
DataDocument
├── Metadata (lastUpdate: int64 - unix ms)
├── Containers (name, friendly_name, url, running, active)
├── Order (container ordering)
├── Groups (grouping)
└── Schedules (start/stop timers)
```


## REST API Endpoints
| Method | Endpoint | Usage |
|--------|----------|-------|
| GET/POST | `/container*` | CRUD containers |
| GET/POST | `/group*` | CRUD groups |
| GET/POST | `/schedule*` | CRUD schedules |
| POST | `/runtime/:name/{start\|stop}` | Runtime commands |
| GET | `/runtime/:name/waiting` | HTML waiting/redirect page for container or group |
| GET | `/ui` | Web UI SPA |

### Details for /runtime/:name/waiting endpoint
- Returns an HTML page (spinner + JS redirect)
- Replaces placeholders `{{CONTAINER_NAME}}` and `{{REDIRECT_URL}}` in the template
- If the container/group is not running, it is started in background
- 404 if not found, 403 if not active, 200 if ok

## Runtime Implementations
- **DockerRuntime**: Uses Moby client, communicates with Docker daemon
- **MemoryRuntime**: Mock for testing without Docker
- **Factory**: `runtime.NewRuntimeFromConfig(runtimeType, doc)`

## Web UI (Alpine.js SPA)
- Accessibile su `/ui`
- File: `ui/index.html` + `ui/assets/app.js`
- Tabs: Containers, Groups, Schedules
- Stack: Alpine.js (reattività) + TailwindCSS (styling CDN) + fetch API JSON

## CORS
- Configurabile in `internal/api/middleware/cors.go`
- Default: `*` (tutte le origini)
- Controllato via `misc.cors_allowed_origins`

## Gestione Errori & Logging
- Errori custom in `cache/` (es. `ErrContainerNotFound`)
- Sempre wrappare con `fmt.Errorf("context: %w", err)`
- Logger per componenti: `[json-repo]`, `[persist]`, `[sched]`

## Dipendenze Critiche
- `gin-gonic/gin` - HTTP framework
- `moby/moby/client` - Docker client
- `spf13/viper` - Configurazione
- `fsnotify/fsnotify` - File watching
- `go-playground/validator` - Validazione struct
- `enrichman/httpgrace` - Graceful shutdown

## Testing Strategy
- Interfacce permettono **mocking senza Docker**
- MemoryRuntime per test in isolation
- Controllare test file per pattern: `*_test.go` in ogni modulo

## Scheduling
- `PollingScheduler` in `internal/scheduler/` effettua polling periodico
- Controllo abilitazione via `misc.scheduling_enabled`
- Intervallo configurabile: `misc.scheduling_poll_interval_secs`
- Timezone: `misc.scheduling_timezone` (default: "Local")
